#jinja2: lstrip_blocks: True, trim_blocks: True
# {{ ansible_managed }}

########################################################################################################################
# You should look at the following URL's in order to grasp a solid understanding of Nginx configuration files in order #
# to fully unleash the power of Nginx.                                                                                 #
# http://wiki.nginx.org/Pitfalls                                                                                       #
# http://wiki.nginx.org/QuickStart                                                                                     #
# http://wiki.nginx.org/Configuration                                                                                  #
#                                                                                                                      #
# Generally, you will want to move this file somewhere, and start with a clean                                         #
# file but keep this around for reference. Or just disable in sites-enabled.                                           #
#                                                                                                                      #
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.                                            #
########################################################################################################################

## Expires map. The 'off' parameter disables adding or modifying the "Expires" and "Cache-Control" response header
## fields.
map $sent_http_content_type $expires {
    default off;
    ~image/ max;
    ~audio/ max;
    ~video/ max;
}

{# build a list of unique ports from the `listen` string #}
{% for port in unique_nginx_listeners %}
{%   set vhost = (nginx_vhosts|selectattr('server_names', 'defined')|selectattr('listen', 'defined')|selectattr('listen', 'search', port)|rejectattr('listen', 'search', 'default_server')|list)[0] %}
## "server" block to prevent connection to the named vhost server without 'Host' header set
server {
    # Nginx tests the request’s header field "Host" to determine which server the request should be routed to. If its
    # value does not match any server name, or the request does not contain this header field at all, then nginx will
    # route the request to the "default_server" for this port.
{%   if 'ssl' in vhost['listen'] or (vhost.ssl_enabled is defined and vhost['ssl_enabled']|bool) %}
    listen                  {{ vhost['listen']|regex_replace('^([0-9]+)+(.*)$', '\\1') }} ssl default_server;

    ssl_certificate         /etc/ssl/certs/ssl-cert-snakeoil.pem;
    ssl_certificate_key     /etc/ssl/private/ssl-cert-snakeoil.key;
{%   else %}
    listen          {{ vhost['listen']|regex_replace('^([0-9]+)+(.*)$', '\\1') }} default_server;
{%   endif %}
    server_name     _ "";

    log_not_found   off;
    access_log      off;

    return          444;
}
{% endfor %}


{% for vhost in nginx_vhosts %}
server {
    listen {{ vhost.listen }};

{# Domain names. Make sure to set the 'A'-record on your domain's DNS settings to your server's IP address. #}
{% if vhost.server_names is defined %}
    server_name {{ vhost.server_names|join(' ') }};
{% endif %}

{% if 'ssl' in vhost['listen'] or (vhost.ssl_enabled is defined and vhost['ssl_enabled']|bool) %}
    ## SSL configuration
{%   if vhost.ssl_with_letsencrypt is defined and vhost['ssl_with_letsencrypt']|bool %}
    ssl_certificate          /etc/letsencrypt/live/{{ vhost.server_names[0] }}/fullchain.pem;
    ssl_certificate_key      /etc/letsencrypt/live/{{ vhost.server_names[0] }}/privkey.pem;
    ssl_trusted_certificate  /etc/letsencrypt/live/{{ vhost.server_names[0] }}/chain.pem;
{%   else %}
    ssl_certificate          {{ vhost.ssl_cert }};
    ssl_certificate_key      {{ vhost.ssl_cert_key }};
{%     if vhost.ssl_trusted_cert is defined and vhost['ssl_trusted_cert']|length > 0 %}
    ssl_trusted_certificate  {{ vhost.ssl_trusted_cert }};

    ## OCSP stapling - means nginx will poll the CA for signed OCSP responses, and send them to clients so clients
    ## don't make their own OCSP calls (https://en.wikipedia.org/wiki/OCSP_stapling).
    ssl_stapling           on;
    ssl_stapling_verify    on;
    resolver               8.8.8.8 8.8.4.4 valid=86400s;
    resolver_timeout       10s;
{%     endif %}
{%   endif %}

    ## Config to enable HSTS (HTTP Strict Transport Security)
    ## https://developer.mozilla.org/en-US/docs/Security/HTTP_Strict_Transport_Security to avoid ssl stripping
    ## https://en.wikipedia.org/wiki/SSL_stripping#SSL_stripping
    ## also see https://hstspreload.org/
    add_header  Strict-Transport-Security "max-age=15768000; includeSubDomains" always;

{% endif %}

{% if vhost.root is defined %}
    root {{ vhost.root }};
{% endif %}

    ## Enables or disables adding or modifying the "Expires" and "Cache-Control" response header fields provided that
    ## the response code equals 200, 201, 204, 206, 301, 302, 303, 304, 307 or 308.
    expires $expires;

{% if vhost.extra_parameters is defined %}
{{ vhost.extra_parameters|indent(4,true) }}
{% endif %}

{% if vhost.locations is defined and vhost.locations|length >0 %}
{# To be able to use variable outside the loop use trick when dictionary pointer cannot change, but entries can! #}
{% set reverseProxy = { 'found': False } %}
{% for location in vhost.locations %}
    location {{ location.path }} {
        {{ location.parameters|indent(8,false) }}
    }
{# see above #}
{% if location.parameters is search('proxy_pass') %}{% if reverseProxy.update({'found':True}) %}{% endif %}{% endif %}
{% endfor %}
{% if not reverseProxy.found %}
    ############################
    # Section for search engines
    ###
    location /favicon.ico {
        access_log    off;
        log_not_found off;
    }
    location /robots.txt {
        access_log    off;
        log_not_found off;
    }
    #######################################################################
    # This prevents hidden files (beginning with a period) from being served
    ###
    location ~ /\. {
      access_log    off;
      log_not_found off;
      deny          all;
    }
  {% if vhost.static_content_locations_enabled is defined and vhost.static_content_locations_enabled %}
    #######################################################################
    # Cache-Control section. Here we define expire rules for static content
    ###
    # HTML documents and data
    location ~* \.(manifest|appcache|html?|xml|json)$ {
        # The Expires HTTP header is a basic means of controlling caches; it tells all caches how long the associated
        # representation is fresh for. After that time, caches will always check back with the origin server to see if
        # a document is changed.
        # "If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age."
        # (source: http://www.ietf.org/rfc/rfc2616.txt, p114)
        # Nginx automatically sets the "Cache-Control: max-age=t" header, if "expires" is present, where <t> is a time
        # specified in the directive, in seconds
        expires -1;
    }
    # Media: images, icons, video, audio, archives, documents
    location ~* \.(bmp|jpe?g|gif|png|ico|cur|mp4|webm|ogv|ogg|mid|midi|wav|bz2|zip|tar|tgz|gz|rar|docx?|xlsx?|pptx?|rtf|htc)$ {
        access_log    off;
        log_not_found off;
        # The Expires HTTP header is a basic means of controlling caches; it tells all caches how long the associated
        # representation is fresh for. After that time, caches will always check back with the origin server to see if
        # a document is changed.
        # "If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age."
        # (source: http://www.ietf.org/rfc/rfc2616.txt, p114)
        # Nginx automatically sets the "Cache-Control: max-age=t" header, if "expires" is present, where <t> is a time
        # specified in the directive, in seconds
        expires                  1w;
        # public:           marks authenticated responses as cacheable; normally, if HTTP authentication is required,
        #                   responses are automatically private.
        add_header Cache-Control "public";
    }
    # Fonts
    location ~* \.(svg.?|eot|otf|woff.?|ttf)$ {
        access_log    off;
        log_not_found off;
        # The Expires HTTP header is a basic means of controlling caches; it tells all caches how long the associated
        # representation is fresh for. After that time, caches will always check back with the origin server to see if
        # a document is changed.
        # "If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age."
        # (source: http://www.ietf.org/rfc/rfc2616.txt, p114)
        # Nginx automatically sets the "Cache-Control: max-age=t" header, if "expires" is present, where <t> is a time
        # specified in the directive, in seconds
        expires                                1w;
        # public:           marks authenticated responses as cacheable; normally, if HTTP authentication is required,
        #                   responses are automatically private.
        add_header Cache-Control               "public";
        # allow CORS requests
        add_header Access-Control-Allow-Origin *;
    }
    # CSS and Javascript
    location ~* \.(css|js)$ {
        access_log    off;
        log_not_found off;
        # no-cache:         forces caches to submit the request to the origin server for validation before releasing a
        #                   cached copy, every time. This is useful to assure that authentication is respected  (in
        #                   combination with public), or to maintain rigid freshness, without sacrificing all of the
        #                   benefits of caching.
        # public:           marks authenticated responses as cacheable; normally, if HTTP authentication is required,
        #                   responses are automatically private.
        # must-revalidate:  tells caches that they must obey any freshness information you give them about a
        #                   representation. HTTP allows caches to serve stale representations under special conditions;
        #                   by specifying this header, you’re telling the cache that you want it to strictly follow
        #                   your rules.
        # proxy-revalidate: similar to must-revalidate, except that it only applies to proxy caches.
        add_header Cache-Control "no-cache, public, must-revalidate, proxy-revalidate";
    }
    # Feed
    location ~* \.(rss|atom)$ {
        access_log    off;
        log_not_found off;
        # The Expires HTTP header is a basic means of controlling caches; it tells all caches how long the associated
        # representation is fresh for. After that time, caches will always check back with the origin server to see if
        # a document is changed.
        # "If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age."
        # (source: http://www.ietf.org/rfc/rfc2616.txt, p114)
        # Nginx automatically sets the "Cache-Control: max-age=t" header, if "expires" is present, where <t> is a time
        # specified in the directive, in seconds
        expires                  1h;
        add_header Cache-Control "private";
    }
  {% endif %}
{% endif %}
{% endif %}
}

{% endfor %}
